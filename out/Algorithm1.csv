,name,f,p,r,text
0,TextRank,0.266645856911126,0.27848101265822783,0.2573099415204678,"An algorithm designed for such an environment is called a serial algorithm, as opposed to parallel algorithms or distributed algorithms. Algorithm versus function computable by an algorithm: For a given function multiple algorithms may exist. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, incorporate random input.The concept of algorithm has existed for centuries. Brute-force search.Some problems may have multiple algorithms of differing complexity, while other problems might have no algorithms or no known efficient algorithms. 3 Formal description+Most detailed, ""lowest level"", gives the Turing machine's ""state table"".For an example of the simple algorithm ""Add m+n"" described in all three levels, see Algorithm#Examples. In the general case, a specialized algorithm or an algorithm that finds approximate solutions is used, depending on the difficulty of the problem. One of the most important aspects of algorithm design is creating an algorithm that has an efficient run-time, also known as its Big O. Whether randomized algorithms with polynomial time complexity can be the fastest algorithms for some problems is an open question known as the P versus NP problem. Simulation of an algorithm: computer (computor) language: Knuth advises the reader that ""the best way to learn an algorithm is to try it . Techniques for designing and implementing algorithm designs are also called algorithm design patterns, such as the template method pattern and decorator pattern. An example of a decrease and conquer algorithm is the binary search algorithm. Because an algorithm is a precise list of precise steps, the order of computation is always crucial to the functioning of the algorithm."
1,Gensim,0.2838461237877427,0.254071661237785,0.45614035087719296,"In mathematics and computer science, an algorithm ( (listen)) is a set of instructions, typically solve a class of problems or perform a computation.
As an effective method, an algorithm can be expressed within a finite amount of space and time and in a well-defined formal language for calculating a function.
Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of well-defined successive states, eventually producing ""output"" and terminating at a final ending state.
An informal definition could be ""a set of rules that precisely defines a sequence of operations"", which would include all computer programs, including programs that do not perform numeric calculations, and (for example) any prescribed bureaucratic procedure.
Such instructions are to be given quite explicitly, in a form in which they could be followed by a computing machine, or by a human who is capable of carrying out only very elementary operations on symbols.
Precise instructions (in language understood by ""the computer"") for a fast, efficient, ""good"" process that specifies the ""moves"" of ""the computer"" (machine or human, equipped with the necessary internally contained information and capabilities) to find, decode, and then process arbitrary input integers/symbols m and n, symbols + and = ...
The design of algorithms is part of many solution theories of operation research, such as dynamic programming and divide-and-conquer.
The same function may have several different algorithms"".Unfortunately, there may be a tradeoff between goodness (speed) and elegance (compactness)—an elegant program may take more steps to complete a computation than one less elegant.
For example, the subprogram in Euclid's algorithm to compute the remainder would execute much faster if the programmer had a ""modulus"" instruction available rather than just subtraction (or worse: just Minsky's ""decrement"").
Structured programming, canonical structures: Per the Church–Turing thesis, any algorithm can be computed by a model known to be Turing complete, and per Minsky's demonstrations, Turing completeness requires only four instruction types—conditional GOTO, unconditional GOTO, assignment, HALT.
In modern words, remainder r = l − q×s, q being the quotient, or remainder r is the ""modulus"", the integer-fractional part left over after the division.For Euclid's method to succeed, the starting lengths must satisfy two requirements: (i) the lengths must not be zero, AND (ii) the subtraction must be “proper”; i.e., a test must guarantee that the smaller of the two numbers is subtracted from the larger (alternately, the two can be equal so their subtraction yields zero).
The following algorithm is framed as Knuth's four-step version of Euclid's and Nicomachus', but, rather than using division to find the remainder, it uses successive subtractions of the shorter length s from the remaining length r until r is less than s.
The analysis, and study of algorithms is a discipline of computer science, and is often practiced abstractly without the use of a specific programming language or implementation.
Iterative algorithms use repetitive constructs like loops and sometimes additional data structures like stacks to solve the given problems."
2,K-mean-2,0.04426876558027411,0.17105263157894737,0.04234527687296417,"Structured programming, canonical structures: Per the Church–Turing thesis, any algorithm can be computed by a model known to be Turing complete, and per Minsky's demonstrations, Turing completeness requires only four instruction types—conditional GOTO, unconditional GOTO, assignment, HALT. For each remaining number in the set: if this number is larger than the current largest number, consider this number to be the largest number in the set. To ""measure"" is to place a shorter measuring length s successively (q times) along longer length l until the remaining portion r is less than the shorter length s. In modern words, remainder r = l − q×s, q being the quotient, or remainder r is the ""modulus"", the integer-fractional part left over after the division.For Euclid's method to succeed, the starting lengths must satisfy two requirements: (i) the lengths must not be zero, AND (ii) the subtraction must be “proper”; i.e., a test must guarantee that the smaller of the two numbers is subtracted from the larger (alternately, the two can be equal so their subtraction yields zero). While Nicomachus' algorithm is the same as Euclid's, when the numbers are prime to one another, it yields the number ""1"" for their common measure. An inelegant program for Euclid's algorithm+The following algorithm is framed as Knuth's four-step version of Euclid's and Nicomachus', but, rather than using division to find the remainder, it uses successive subtractions of the shorter length s from the remaining length r until r is less than s. The high-level description, shown in boldface, is adapted from Knuth 1973:2–4:+INPUT:++1 [Into two locations L and S put the numbers l and s that represent the two lengths]:+  INPUT L, S+2 [Initialize R: make the remaining length r equal to the starting/initial/input length l]:+  R ← L++E0: [Ensure r ≥ s.]++3 [Ensure the smaller of the two numbers is in S and the larger in R]:+  IF R > S THEN+    the contents of L is the larger number so skip over the exchange-steps 4, 5 and 6:+    GOTO step 6+  ELSE+    swap the contents of R and S.+4   L ← R (this first step is redundant, but is useful for later discussion). Observe that steps 4, 5 and 6 are repeated in steps 11, 12 and 13. Such algorithms include local search, tabu search, simulated annealing, and genetic algorithms. Some of them, like simulated annealing, are non-deterministic algorithms while others, like tabu search, are deterministic. When a bound on the error of the non-optimal solution is known, the algorithm is further categorized as an approximation algorithm. By field of study+Every field of science has its own problems and needs efficient algorithms. Related problems in one field are often studied together. Some example classes are search algorithms, sorting algorithms, merge algorithms, numerical algorithms, graph algorithms, string algorithms, computational geometric algorithms, combinatorial algorithms, medical algorithms, machine learning, cryptography, data compression algorithms and parsing techniques."
3,K-mean-3,0.030262363489626066,0.14516129032258066,0.029315960912052116,"Gurevich: ""...Turing's informal argument in favor of his thesis justifies a stronger thesis: every algorithm can be simulated by a Turing machine ... according to Savage [1987], an algorithm is a computational process defined by a Turing machine"". Programming languages are primarily intended for expressing algorithms in a form that can be executed by a computer but are often used as a way to define or document algorithms. Structured programming, canonical structures: Per the Church–Turing thesis, any algorithm can be computed by a model known to be Turing complete, and per Minsky's demonstrations, Turing completeness requires only four instruction types—conditional GOTO, unconditional GOTO, assignment, HALT. Assume the first number in the set is the largest number in the set. For each remaining number in the set: if this number is larger than the current largest number, consider this number to be the largest number in the set. Euclid stipulated this so that he could construct a reductio ad absurdum proof that the two numbers' common measure is in fact the greatest. A location is symbolized by upper case letter(s), e.g. S, A, etc. By field of study+Every field of science has its own problems and needs efficient algorithms. Some example classes are search algorithms, sorting algorithms, merge algorithms, numerical algorithms, graph algorithms, string algorithms, computational geometric algorithms, combinatorial algorithms, medical algorithms, machine learning, cryptography, data compression algorithms and parsing techniques. Linear time: if the time is proportional to the input size. Logarithmic time: if the time is a logarithmic function of the input size. In rapid succession the following appeared: Alonzo Church, Stephen Kleene and J.B. Rosser's λ-calculus a finely honed definition of ""general recursion"" from the work of Gödel acting on suggestions of Jacques Herbrand (cf."
4,K-mean-4,0.0373543231256494,0.1506849315068493,0.035830618892508145,"For each remaining number in the set: if this number is larger than the current largest number, consider this number to be the largest number in the set. He defines ""A number [to be] a multitude composed of units"": a counting number, a positive integer not including zero. An inelegant program for Euclid's algorithm+The following algorithm is framed as Knuth's four-step version of Euclid's and Nicomachus', but, rather than using division to find the remainder, it uses successive subtractions of the shorter length s from the remaining length r until r is less than s. The high-level description, shown in boldface, is adapted from Knuth 1973:2–4:+INPUT:++1 [Into two locations L and S put the numbers l and s that represent the two lengths]:+  INPUT L, S+2 [Initialize R: make the remaining length r equal to the starting/initial/input length l]:+  R ← L++E0: [Ensure r ≥ s.]++3 [Ensure the smaller of the two numbers is in S and the larger in R]:+  IF R > S THEN+    the contents of L is the larger number so skip over the exchange-steps 4, 5 and 6:+    GOTO step 6+  ELSE+    swap the contents of R and S.+4   L ← R (this first step is redundant, but is useful for later discussion). Serial, parallel or distributed+Algorithms are usually discussed with the assumption that computers execute one instruction of an algorithm at a time. One such example of divide and conquer is merge sorting. For example, one selection algorithm for finding the median in an unsorted list involves first sorting the list (the expensive portion) and then pulling out the middle element in the sorted list (the cheap portion). Dynamic programming+When a problem shows optimal substructures—meaning the optimal solution to a problem can be constructed from optimal solutions to subproblems—and overlapping subproblems, meaning the same subproblems are used to solve many different problem instances, a quicker approach called dynamic programming avoids recomputing solutions that have already been computed. By field of study+Every field of science has its own problems and needs efficient algorithms. Some example classes are search algorithms, sorting algorithms, merge algorithms, numerical algorithms, graph algorithms, string algorithms, computational geometric algorithms, combinatorial algorithms, medical algorithms, machine learning, cryptography, data compression algorithms and parsing techniques. the bubble sort algorithm has quadratic time complexity. The paradoxes: At the same time a number of disturbing paradoxes appeared in the literature, in particular, the Burali-Forti paradox (1897), the Russell paradox (1902–03), and the Richard Paradox. In rapid succession the following appeared: Alonzo Church, Stephen Kleene and J.B. Rosser's λ-calculus a finely honed definition of ""general recursion"" from the work of Gödel acting on suggestions of Jacques Herbrand (cf. Alan Turing's proof of that the Entscheidungsproblem was unsolvable by use of his ""a- [automatic-] machine""—in effect almost identical to Post's ""formulation"", J. Barkley Rosser's definition of ""effective method"" in terms of ""a machine""."
5,K-mean-5,0.0366803483853297,0.21153846153846154,0.035830618892508145,"But Minsky shows (as do Melzak and Lambek) that his machine is Turing complete with only four general types of instructions: conditional GOTO, unconditional GOTO, assignment/replacement/substitution, and HALT. For example, the subprogram in Euclid's algorithm to compute the remainder would execute much faster if the programmer had a ""modulus"" instruction available rather than just subtraction (or worse: just Minsky's ""decrement""). Assume the first number in the set is the largest number in the set. For each remaining number in the set: if this number is larger than the current largest number, consider this number to be the largest number in the set. A location is symbolized by upper case letter(s), e.g. The varying quantity (number) in a location is written in lower case letter(s) and (usually) associated with the location's name. Now ""Elegant"" computes the example-numbers faster; whether this is always the case for any given A, B, and R, S would require a detailed analysis. Divide and conquer+A divide and conquer algorithm repeatedly reduces an instance of a problem to one or more smaller instances of the same problem (usually recursively) until the instances are small enough to solve easily. A linear programming algorithm can solve such a problem if it can be proved that all restrictions for integer values are superficial, i.e., the solutions satisfy these restrictions anyway. Dynamic programming+When a problem shows optimal substructures—meaning the optimal solution to a problem can be constructed from optimal solutions to subproblems—and overlapping subproblems, meaning the same subproblems are used to solve many different problem instances, a quicker approach called dynamic programming avoids recomputing solutions that have already been computed. These algorithms work by getting closer and closer to the optimal solution as they progress. Some of them, like simulated annealing, are non-deterministic algorithms while others, like tabu search, are deterministic. Some example classes are search algorithms, sorting algorithms, merge algorithms, numerical algorithms, graph algorithms, string algorithms, computational geometric algorithms, combinatorial algorithms, medical algorithms, machine learning, cryptography, data compression algorithms and parsing techniques."
6,K-mean-6,0.03995217664705933,0.24,0.03908794788273615,"As an effective method, an algorithm can be expressed within a finite amount of space and time and in a well-defined formal language for calculating a function. One criterion ... is the length of time taken to perform the algorithm .... Other criteria are adaptability of the algorithm to computers, its simplicity and elegance, etc""Chaitin: "" ... a program is 'elegant,' by which I mean that it's the smallest possible program for producing the output that it does""Chaitin prefaces his definition with: ""I'll show you can't prove that a program is 'elegant'""—such a proof would solve the Halting problem (ibid). An example that uses Euclid's algorithm appears below. When speed is being measured, the instruction set matters. From this follows a simple algorithm, which can be stated in a high-level description in English prose, as:+High-level description:++If there are no numbers in the set then there is no highest number. For each remaining number in the set: if this number is larger than the current largest number, consider this number to be the largest number in the set. This works because, when at last the minuend M is less than or equal to the subtrahend S ( Difference = Minuend − Subtrahend), the minuend can become s (the new measuring length) and the subtrahend can become the new r (the length to be measured); in other words the ""sense"" of the subtraction reverses. But tests are not enough. This technique is also known as transform and conquer. Some of them, like simulated annealing, are non-deterministic algorithms while others, like tabu search, are deterministic. Brute-force search.Some problems may have multiple algorithms of differing complexity, while other problems might have no algorithms or no known efficient algorithms. If he wishes to observe more, he must use successive observations. ""(B) A possible change (b) of observed squares, together with a possible change of state of mind""""We may now construct a machine to do the work of this computer."
7,K-mean-7,0.03725185290265747,0.15714285714285714,0.035830618892508145,"However, a few different assignment instructions (e.g. Assume the first number in the set is the largest number in the set. For each remaining number in the set: if this number is larger than the current largest number, consider this number to be the largest number in the set. The varying quantity (number) in a location is written in lower case letter(s) and (usually) associated with the location's name. An inelegant program for Euclid's algorithm+The following algorithm is framed as Knuth's four-step version of Euclid's and Nicomachus', but, rather than using division to find the remainder, it uses successive subtractions of the shorter length s from the remaining length r until r is less than s. The high-level description, shown in boldface, is adapted from Knuth 1973:2–4:+INPUT:++1 [Into two locations L and S put the numbers l and s that represent the two lengths]:+  INPUT L, S+2 [Initialize R: make the remaining length r equal to the starting/initial/input length l]:+  R ← L++E0: [Ensure r ≥ s.]++3 [Ensure the smaller of the two numbers is in S and the larger in R]:+  IF R > S THEN+    the contents of L is the larger number so skip over the exchange-steps 4, 5 and 6:+    GOTO step 6+  ELSE+    swap the contents of R and S.+4   L ← R (this first step is redundant, but is useful for later discussion). If a problem additionally requires that one or more of the unknowns must be an integer then it is classified in integer programming. Dynamic programming+When a problem shows optimal substructures—meaning the optimal solution to a problem can be constructed from optimal solutions to subproblems—and overlapping subproblems, meaning the same subproblems are used to solve many different problem instances, a quicker approach called dynamic programming avoids recomputing solutions that have already been computed. Some of them, like simulated annealing, are non-deterministic algorithms while others, like tabu search, are deterministic. Some example classes are search algorithms, sorting algorithms, merge algorithms, numerical algorithms, graph algorithms, string algorithms, computational geometric algorithms, combinatorial algorithms, medical algorithms, machine learning, cryptography, data compression algorithms and parsing techniques. the traverse of a list. Exponential time: if the time is an exponential function of the input size. The paradoxes: At the same time a number of disturbing paradoxes appeared in the literature, in particular, the Burali-Forti paradox (1897), the Russell paradox (1902–03), and the Richard Paradox. Alan Turing's proof of that the Entscheidungsproblem was unsolvable by use of his ""a- [automatic-] machine""—in effect almost identical to Post's ""formulation"", J. Barkley Rosser's definition of ""effective method"" in terms of ""a machine""."
8,K-mean-8,0.03738880199295015,0.14864864864864866,0.035830618892508145,"Gurevich: ""...Turing's informal argument in favor of his thesis justifies a stronger thesis: every algorithm can be simulated by a Turing machine ... according to Savage [1987], an algorithm is a computational process defined by a Turing machine"". For example, the subprogram in Euclid's algorithm to compute the remainder would execute much faster if the programmer had a ""modulus"" instruction available rather than just subtraction (or worse: just Minsky's ""decrement""). An inelegant program for Euclid's algorithm+The following algorithm is framed as Knuth's four-step version of Euclid's and Nicomachus', but, rather than using division to find the remainder, it uses successive subtractions of the shorter length s from the remaining length r until r is less than s. The high-level description, shown in boldface, is adapted from Knuth 1973:2–4:+INPUT:++1 [Into two locations L and S put the numbers l and s that represent the two lengths]:+  INPUT L, S+2 [Initialize R: make the remaining length r equal to the starting/initial/input length l]:+  R ← L++E0: [Ensure r ≥ s.]++3 [Ensure the smaller of the two numbers is in S and the larger in R]:+  IF R > S THEN+    the contents of L is the larger number so skip over the exchange-steps 4, 5 and 6:+    GOTO step 6+  ELSE+    swap the contents of R and S.+4   L ← R (this first step is redundant, but is useful for later discussion). The following version can be used with Object Oriented languages:++Testing the Euclid algorithms+Does an algorithm do what its author wants it to do? But tests are not enough. The compactness of ""Inelegant"" can be improved by the elimination of five steps. Algorithmic analysis+It is frequently important to know how much of a particular resource (such as time or storage) is theoretically required for a given algorithm. Different algorithms may complete the same task with a different set of instructions in less or more time, space, or 'effort' than others. There are algorithms that can solve any problem in this category, such as the popular simplex algorithm. Dynamic programming+When a problem shows optimal substructures—meaning the optimal solution to a problem can be constructed from optimal solutions to subproblems—and overlapping subproblems, meaning the same subproblems are used to solve many different problem instances, a quicker approach called dynamic programming avoids recomputing solutions that have already been computed. Some example classes are search algorithms, sorting algorithms, merge algorithms, numerical algorithms, graph algorithms, string algorithms, computational geometric algorithms, combinatorial algorithms, medical algorithms, machine learning, cryptography, data compression algorithms and parsing techniques. Turing's biographer believed that Turing's use of a typewriter-like model derived from a youthful interest: ""Alan had dreamt of inventing typewriters as a boy; Mrs. Turing had a typewriter, and he could well have begun by asking himself what was meant by calling a typewriter 'mechanical'"". ""(B) A possible change (b) of observed squares, together with a possible change of state of mind""""We may now construct a machine to do the work of this computer."
9,K-mean-9,0.04382755382683698,0.2,0.04234527687296417,"Representations of algorithms can be classed into three accepted levels of Turing machine description:+1 High-level description+""...prose to describe an algorithm, ignoring the implementation details. However, a few different assignment instructions (e.g. Kemeny and Kurtz observe that, while ""undisciplined"" use of unconditional GOTOs and conditional IF-THEN GOTOs can result in ""spaghetti code"", a programmer can write structured programs using only these instructions; on the other hand ""it is also possible, and not too hard, to write badly structured programs in a structured language"". Finding the solution requires looking at every number in the list. For each remaining number in the set: if this number is larger than the current largest number, consider this number to be the largest number in the set. 5   R ← S+6   S ← L++E1: [Find remainder]: Until the remaining length r in R is less than the shorter length s in S, repeatedly subtract the measuring number s in S from the remaining length r in R.++7 IF S > R THEN+    done measuring so+    GOTO 10+  ELSE+    measure again,+8   R ← R − S+9   [Remainder-loop]:+    GOTO 7. In the (unstructured) Basic language, the steps are numbered, and the instruction LET [] = [] is the assignment instruction symbolized by ←. There are algorithms that can solve any problem in this category, such as the popular simplex algorithm. Dynamic programming+When a problem shows optimal substructures—meaning the optimal solution to a problem can be constructed from optimal solutions to subproblems—and overlapping subproblems, meaning the same subproblems are used to solve many different problem instances, a quicker approach called dynamic programming avoids recomputing solutions that have already been computed. Some example classes are search algorithms, sorting algorithms, merge algorithms, numerical algorithms, graph algorithms, string algorithms, computational geometric algorithms, combinatorial algorithms, medical algorithms, machine learning, cryptography, data compression algorithms and parsing techniques. an access to an array element. Exponential time: if the time is an exponential function of the input size. ""(B) A possible change (b) of observed squares, together with a possible change of state of mind""""We may now construct a machine to do the work of this computer."
10,K-mean-10,0.04038501272428134,0.19047619047619047,0.03908794788273615,"Greek mathematicians used algorithms in the sieve of Eratosthenes for finding prime numbers, and the Euclidean algorithm for finding the greatest common divisor of two numbers.The word algorithm itself is derived from the 9th century mathematician Muḥammad ibn Mūsā al-Khwārizmī, Latinized Algoritmi. For some alternate conceptions of what constitutes an algorithm see functional programming and logic programming. There is a wide variety of representations possible and one can express a given Turing machine program as a sequence of machine tables (see more at finite-state machine, state transition table and control table), as flowcharts and drakon-charts (see more at state diagram), or as a form of rudimentary machine code or assembly code called ""sets of quadruples"" (see more at Turing machine). An optimal algorithm, even running in old hardware, would produce faster results than a non-optimal (higher time complexity) algorithm for the same purpose, running in more efficient hardware; that is why algorithms, like computer hardware, are considered technology. the instruction "" Z ← 0 ""; thereafter the instruction IF Z=0 THEN GOTO xxx is unconditional. Examples+Algorithm example+One of the simplest algorithms is to find the largest number in a list of numbers of random order. He defines ""A number [to be] a multitude composed of units"": a counting number, a positive integer not including zero. Computer language for Euclid's algorithm+Only a few instruction types are required to execute Euclid's algorithm—some logical tests (conditional GOTO), unconditional GOTO, assignment (replacement), and subtraction. One such example of divide and conquer is merge sorting. The heuristic method+In optimization problems, heuristic algorithms can be used to find a solution close to the optimal solution in cases where finding the optimal solution is impractical. Polynomial time: if the time is a power of the input size. Brute-force search.Some problems may have multiple algorithms of differing complexity, while other problems might have no algorithms or no known efficient algorithms. We may suppose that there is a bound B to the number of symbols or squares which the computer can observe at one moment."
11,Cosine Similarity,0.2431542965902064,0.23626373626373626,0.25146198830409355,"In mathematics and computer science, an algorithm ( (listen)) is a set of instructions, typically solve a class of problems or perform a computation. Some problems have no parallel algorithms and are called inherently serial problems. Serial, parallel or distributed+Algorithms are usually discussed with the assumption that computers execute one instruction of an algorithm at a time. J.B. Rosser (1939) and S.C. Kleene (1943)+J. Barkley Rosser defined an 'effective [mathematical] method' in the following manner (italicization added):++""'Effective method' is used here in the rather special sense of a method each step of which is precisely determined and which is certain to produce the answer in a finite number of steps. Formalization+Algorithms are essential to the way computers process data. The same function may have several different algorithms"".Unfortunately, there may be a tradeoff between goodness (speed) and elegance (compactness)—an elegant program may take more steps to complete a computation than one less elegant. In principle, if run for an infinite amount of time, they will find the optimal solution. Therefore, it is said to have a space requirement of O(1), if the space required to store the input numbers is not counted, or O(n) if it is counted. Techniques for designing and implementing algorithm designs are also called algorithm design patterns, such as the template method pattern and decorator pattern. If they don't, then the algorithm, to be effective, must provide a set of rules for extracting a square root.This means that the programmer must know a ""language"" that is effective relative to the target computing agent (computer/computor). The heuristic method+In optimization problems, heuristic algorithms can be used to find a solution close to the optimal solution in cases where finding the optimal solution is impractical. RP is the subclass of these that run in polynomial time."
